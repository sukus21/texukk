package main

import (
	"flag"
	"fmt"
	"image/png"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	"github.com/sukus21/texukk"
)

var rootName = ""

var fPath = flag.String("source", "", "path to source images")
var fWidth = flag.Int("width", 512, "width generated texture")
var fHeight = flag.Int("height", 512, "height of generated texture")
var fRecursive = flag.Bool("recursive", false, "look through subfolders")
var fPackage = flag.String("package", "", "package name of exported file")
var fEmbed = flag.Bool("embed", false, "embed the output image within the file")
var fFormat = flag.String("format", "uint32", "name of type to store coordinates as")
var fNormalized = flag.Bool("normalize", false, "normalize texture coordinates (only works with float32 and float64 format)")
var fOut = flag.String("out", "", "output for atlas and texture coordinate file")

func pathToName(pathName string) string {
	illegal := []rune{'/', '\\', '.', '_', '-'}
	nextUpper := true
	out := ""
	lastPeriod := -1
	for _, v := range pathName {
		if slices.Contains(illegal, v) {
			nextUpper = true
			if v == '.' {
				lastPeriod = len(out)
			}
			continue
		}
		if nextUpper {
			out += strings.ToUpper(string(v))
			nextUpper = false
		} else {
			out += string(v)
		}
	}
	if lastPeriod != -1 {
		out = out[:lastPeriod]
	}
	if len(out) > len(rootName) && out[:len(rootName)] == rootName {
		out = out[len(rootName):]
	}
	return out
}

func main() {
	flag.Parse()
	if *fHeight == 0 {
		*fHeight = *fWidth
	}
	if *fPath == "" || *fWidth == 0 || *fHeight == 0 {
		flag.Usage()
		os.Exit(1)
	}

	// Validate chosen coordinate format
	format := *fFormat
	width := *fWidth
	height := *fHeight
	switch format {
	case "uint8":
		if width >= 0x100 || height >= 0x100 {
			log.Fatal("texture too big for uint8 coordinates")
		}
	case "uint16":
		if width >= 0x10000 || height >= 0x10000 {
			log.Fatal("texture too big for uint16 coordinates")
		}
	case "uint32", "uint64", "float32", "float64":
		// Do nothing, these are fine
	default:
		log.Fatalf("invalid coordinate for at '%s' chosen", format)
	}
	if *fNormalized && format != "float64" && format != "float32" {
		log.Fatal("normalized coordinates only supported for float32 and float64 formats")
	}

	atlas, mapping, err := texukk.RenderFromFolder(*fPath, width, height, *fRecursive)
	if err != nil {
		log.Fatal(err)
	}

	names := make([]string, 0, len(mapping))
	for k := range mapping {
		names = append(names, k)
	}
	slices.Sort(names)

	// Create filenames of export files
	rootName = pathToName(*fPath)
	outDir, texFile := filepath.Split(*fPath)
	if *fOut != "" {
		outDir = *fOut
	}
	texName := strings.ToUpper(texFile[:1]) + texFile[1:]
	outBasename := strings.ToLower(texFile)
	outFile := filepath.Join(outDir, outBasename)

	// Create output files
	imgFile, err := os.Create(outFile + ".png")
	if err != nil {
		log.Fatal(err)
	}
	err = png.Encode(imgFile, atlas)
	imgFile.Close()
	if err != nil {
		log.Fatal(err)
	}

	// Create go file with mapping data
	goFile, err := os.Create(outFile + ".go")
	if err != nil {
		log.Fatal(err)
	}

	// Get package name
	if *fPackage == "" {
		*fPackage = filepath.Base(outDir)
	}

	// Comments and package name
	fmt.Fprintln(goFile, "// Code generated by go generate; DO NOT EDIT.")
	fmt.Fprintln(goFile, "// Generated using 'github.com/sukus21/texukk/cmd/texukk'.")
	fmt.Fprintf(goFile, "// Generated at %s.\n", time.Now())
	fmt.Fprintln(goFile)
	fmt.Fprintln(goFile, "package", *fPackage)
	fmt.Fprintln(goFile)

	// Imports
	fmt.Fprintln(goFile, "import (")
	fmt.Fprintln(goFile, "\t\"github.com/sukus21/texukk\"")
	if *fEmbed {
		fmt.Fprintln(goFile, "\t_ \"embed\"")
	}
	fmt.Fprintln(goFile, ")")
	fmt.Fprintln(goFile)

	// Embed texture file or filename
	if *fEmbed {
		fmt.Fprintf(goFile, "//go:embed \"%s.png\"\nvar %sData []byte\n", outBasename, texName)
	} else {
		fmt.Fprintf(goFile, "var %sFilename string = \"%s.png\"\n", texName, strings.ReplaceAll(outFile, "\\", "\\\\"))
	}
	fmt.Fprintln(goFile)

	// Atlas mapping data
	fmt.Fprintf(goFile, "var %s = struct{\n", texName)
	for _, k := range names {
		keyName := pathToName(k)
		fmt.Fprintf(goFile, "\t%s texukk.AtlasTexture[%s]\n", keyName, format)
	}

	goFile.WriteString("}{\n")
	for _, k := range names {
		v := mapping[k]
		keyName := pathToName(k)
		if !*fNormalized {
			fmt.Fprintf(
				goFile,
				"\t%s: texukk.TexCoords[%s](%d, %d, %d, %d),\n",
				keyName, format,
				v.Min.X, v.Min.Y,
				v.Max.X, v.Max.Y,
			)
		} else {
			fmt.Fprintf(
				goFile,
				"\t%s: texukk.TexCoords[%s](%f, %f, %f, %f),\n",
				keyName, format,
				float64(v.Min.X)/float64(width), float64(v.Min.Y)/float64(height),
				float64(v.Max.X)/float64(width), float64(v.Max.Y)/float64(height),
			)
		}
	}
	goFile.WriteString("}\n")
	goFile.Close()
}
